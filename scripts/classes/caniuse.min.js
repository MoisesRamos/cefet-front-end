(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*jshint curly: true, eqeqeq: true, immed: true, indent: 4, browser: true, jquery: true, evil: true, regexdash: true, browser: true, trailing: true, sub: true, unused: true, devel: true */

// author: andi smith
// website: www.andismith.com
// version: 0.1

var canIUse = (function () {

    /*  CONFIGURATION =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */

    //  URL to the data feed
    var SOURCE_DATA_URL = 'https://raw.github.com/Fyrd/caniuse/master/data.json';

    /*  Turn auto run on page load on or off with AUTO_RUN.
        If you turn it off, just use canIUse.render() to kick it off again.
        If you don't want the WhenCanIUse data to load in the background, turn BE_READY to false.
    */
    var AUTO_RUN = true,
        BE_READY = true;

    /*  Configure the browsers you want to show here.
        The order defines the order they will appear on the page.

        Browser options are:
        * android   - Android
        * and_ff    - Android Firefox
        * and_chr   - Android Chrome
        * bb        - Blackberry
        * chrome    - Google Chrome
        * firefox   - Mozilla Firefox
        * ie        - Internet Explorer
        * ios_saf   - iOS Safari
        * opera     - Opera
        * op_mini   - Opera Mini
        * op_mob    - Opera Mobile
        * safari    - Apple Safari
    */
    var BROWSERS = ['chrome', 'firefox', 'ie', 'opera', 'safari'];

    //  Customise HTML here
    var TMPL_TITLE = '<h2>{title}</h2>', // feature title {title}
        TMPL_STATUS = '<p class="status">{status}</p>', // feature status (W3C Recommendation) {status}
        TMPL_DESCRIPTION = '<p>Suportado a partir de:</p>', // description to user
        TMPL_DESKTOP_TITLE = '', // desktop header
        TMPL_MOBILE_TITLE = '', // mobile header
        TMPL_SUPPORT_WRAPPER = '<ul class="agents">{items}</ul>', // support wrapper {items}
        TMPL_SUPPORT = '<li title="{browser} - {support}" class="icon-{browsercode} {supportcode}"><span class="version">{version}{prefixed}</span></li>',
        TMPL_PREFIX_NOTE = '<p>* requer prefixo.</p>',
        TMPL_LEGEND = '<ul class="legend"><li>Legenda:</li><li class="y">Sim</li><li class="n">Não</li><li class="a">Parcial</li><li class="p">Polyfill</li></ul>',
        TMPL_FOOTER = '<p class="stats">Dados de <a href="http://caniuse.com/#feat={feature}" target="_blank">caniuse.com</a></p>',
        TMPL_LOADING = '<h2>Carregando</h2>',
        TMPL_ERROR = '<h2>Erro</h2><p>Feature "{feature}" não encontrada!</p>';

    /* END CONFIGURATION =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */

    var canIUseData, // store data for multiple uses.
        storeElementId, // temp storage for elementId if we need to JSONP request
        populateOnLoad; // temp storage for if we should populate



    // get feature data based on feature name
    function getFeature(featureName) {
        featureName = featureName.toLowerCase();
        if (canIUseData.query) {
            return canIUseData.query.results.json.data[featureName];
        } else if (canIUseData.data) {
            return canIUseData.data[featureName];
        } else {
            return null;
        }
    }

    // get the full text description for the support status
    function getSupportStatus(key) {
        var status = {
            "y": "Yes",
            "x": "With Prefix",
            "n": "No",
            "a": "Partial Support",
            "p": "Polyfill",
            "u": "Unknown"
        };

        return status[key];
    }

    // get the specification status
    function getSpecStatus(key) {
        var status = {
            "rec": "W3C Recommendation",
            "pr": "W3C Proposed Recommendation",
            "cr": "W3C Candidate Recommendation",
            "wd": "W3C Working Draft",
            "other": "Non-W3C, but Reputable",
            "unoff": "Unofficial or W3C 'Note'"
        };

        return status[key] || "Unknown";
    }

    // find the first version that had this status
    function find(needle, haystack) {

        var result = {
                "version": -1,
                "prefixed": false
            },
            compare = -1;

        for (var item in haystack) {
            if (haystack.hasOwnProperty(item) && haystack[item].indexOf(needle) > -1) {
                // some browser versions are formatted n-n, take the first number for comparison
                compare = parseFloat(item.split('-')[0]);
                // is this version lower than the current version we have stored?
                if (result.version === -1 || result.version > compare) {
                    result.version = compare;
                    result.prefixed = (haystack[item].indexOf('x') > -1);
                }
            }
        }
        return result;
    }

    function findSupport(browserData) {
        var status = ['y', 'a', 'p'],
            result = {};
        // find what support is available for this browser
        for (var i = 0; i < status.length; i++) {
            result = find(status[i], browserData);
            if (result.version !== -1) {
                return {
                    'result': status[i], // what type of support
                    'prefixed': result.prefixed,
                    'version': (result.version !== '0') ? result.version : '0' // the version with that support
                };
            }
        }
        return {
            'result': 'n',
            'prefixed': false,
            'version': 'No'
        };
    }

    /* put the data in a more platable format */
    function generateResults(feature) {
        var agents = {},
            results = {},
            currentBrowser = '',
            support = {};

        agents = canIUseData.agents || canIUseData.query.results.json.agents;

        results.title = feature.title; // feature name
        results.code = feature; // feature code?
        results.status = getSpecStatus(feature.status); // feature specification status
        results.agents = [];

        for (var i = 0, l = BROWSERS.length; i < l; i++) {

            currentBrowser = BROWSERS[i];

            if (agents[currentBrowser]) {

                support = findSupport(feature.stats[BROWSERS[i]]);

                results.agents.push({
                    "browsercode": currentBrowser,
                    "prefixed": support.prefixed,
                    "supportcode": support.result,
                    "support": getSupportStatus(support.result),
                    "title": agents[currentBrowser].browser,
                    "type": agents[currentBrowser].type.toLowerCase(),
                    "version": support.version
                });
            }
        }

        return results;
    }


    function generateHtml(results) {

        var html = '',
            resultHtml = '',
            desktopHtml = '',
            mobileHtml = '',
            prefixes = false,
            result = {},
            i = 0,
            l = 0;

        resultHtml = TMPL_TITLE.replace('{title}', results.title);
        resultHtml += TMPL_STATUS.replace('{status}', results.status);
        resultHtml += TMPL_DESCRIPTION;

        for (i = 0, l = results.agents.length; i < l; i++) {
            result = results.agents[i]; // simply things

            // we need to show that prefix notice, captain
            if (result.prefixed) {
                prefixes = true;
            }

            html = TMPL_SUPPORT.replace(/\{browsercode\}/g, result.browsercode)
                                    .replace(/\{prefixed\}/g, (result.prefixed === true) ? '*' : '')
                                    .replace(/\{supportcode\}/g, result.supportcode)
                                    .replace(/\{support\}/g, result.support)
                                    .replace(/\{browser\}/g, result.title)
                                    .replace(/\{version\}/g, result.version);

            if (result.type === 'desktop') {
                desktopHtml += html;
            } else if (result.type === 'mobile') {
                mobileHtml += html;
            }
        }

        // only show if we are including desktop browsers
        if (desktopHtml !== '') {
            resultHtml += TMPL_DESKTOP_TITLE;
            resultHtml += TMPL_SUPPORT_WRAPPER.replace(/\{items\}/g, desktopHtml);
        }

        // only show if we are including mobile browsers
        if (mobileHtml !== '') {
            resultHtml += TMPL_MOBILE_TITLE;
            resultHtml += TMPL_SUPPORT_WRAPPER.replace(/\{items\}/g, mobileHtml);
        }

        if (prefixes) {
            resultHtml += TMPL_PREFIX_NOTE;
        }

        resultHtml += TMPL_LEGEND;
        resultHtml += TMPL_FOOTER.replace(/\{feature\}/g, results.featureCode);
        return resultHtml;
    }

    function generate(elementId) {
        var $canIUse = [],
            $instance,
            featureCode = '',
            feature = {},
            result = {},
            i = 0,
            l = 0;

        if (typeof elementId === "undefined") {
            $canIUse = document.querySelectorAll('.caniuse');
        } else {
            $canIUse.push(document.getElementById(elementId));
        }

        l = $canIUse.length;

        for (i = 0; i < l; i++) {
            $instance = $canIUse[i];
            featureCode = $instance.getAttribute('data-feature') || 'unknown';
            feature = getFeature(featureCode);
            if (feature) {
                result = generateResults(feature);
                result.featureCode = featureCode;
                $instance.innerHTML = generateHtml(result);
            } else {
                $instance.innerHTML = TMPL_ERROR.replace(/\{feature\}/g, featureCode);
            }
        }
    }

    function showLoading(elementId) {
        var $canIUse = [],
            $instance,
            i = 0,
            l = 0;

        if (typeof elementId === "undefined") {
            $canIUse = document.querySelectorAll('.caniuse');
        } else {
            $canIUse.push(document.getElementById(elementId));
        }

        l = $canIUse.length;

        for (i = 0; i < l; i++) {
            $instance = $canIUse[i];
            $instance.innerHTML = TMPL_LOADING;
        }
    }

    /*
     * Load the data that will be used to display information.
     */
    function loadData(elementId, populate) {
        var url = '',
            script = document.createElement('SCRIPT');

        url = 'http://query.yahooapis.com/v1/public/yql?q=' +
            'select * from json where url = \'' + SOURCE_DATA_URL + '\'' +
            '&format=json&jsonCompat=new&callback=canIUseDataLoaded';

        // remember these for when our JSONP returns
        storeElementId = elementId;
        populateOnLoad = populate;

        script.src = url;
        document.body.appendChild(script);
    }

    function populate(elementId) {
        if (typeof canIUseData === 'undefined') {
            showLoading(elementId);
            loadData(elementId, true);
        } else {
            generate(elementId);
        }
    }

    /*
     * Public Methods
     */
    return {
        render: populate,
        dataLoaded: function (data) {
            canIUseData = data;
            if (populateOnLoad) {
                generate(storeElementId);
            }
        },
        init: (function () {
            if (AUTO_RUN) {
                populate();
            } else if (BE_READY) {
                loadData(undefined, false);
            }
        })()
    };
}());

window.canIUseDataLoaded = function canIUseDataLoaded(data) {
    canIUse.dataLoaded(data);
};

},{}]},{},[1])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzY3JpcHRzL2NsYXNzZXMvY2FuaXVzZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmpzaGludCBjdXJseTogdHJ1ZSwgZXFlcWVxOiB0cnVlLCBpbW1lZDogdHJ1ZSwgaW5kZW50OiA0LCBicm93c2VyOiB0cnVlLCBqcXVlcnk6IHRydWUsIGV2aWw6IHRydWUsIHJlZ2V4ZGFzaDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSwgdHJhaWxpbmc6IHRydWUsIHN1YjogdHJ1ZSwgdW51c2VkOiB0cnVlLCBkZXZlbDogdHJ1ZSAqL1xuXG4vLyBhdXRob3I6IGFuZGkgc21pdGhcbi8vIHdlYnNpdGU6IHd3dy5hbmRpc21pdGguY29tXG4vLyB2ZXJzaW9uOiAwLjFcblxudmFyIGNhbklVc2UgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgLyogIENPTkZJR1VSQVRJT04gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS0gKi9cblxuICAgIC8vICBVUkwgdG8gdGhlIGRhdGEgZmVlZFxuICAgIHZhciBTT1VSQ0VfREFUQV9VUkwgPSAnaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9GeXJkL2Nhbml1c2UvbWFzdGVyL2RhdGEuanNvbic7XG5cbiAgICAvKiAgVHVybiBhdXRvIHJ1biBvbiBwYWdlIGxvYWQgb24gb3Igb2ZmIHdpdGggQVVUT19SVU4uXG4gICAgICAgIElmIHlvdSB0dXJuIGl0IG9mZiwganVzdCB1c2UgY2FuSVVzZS5yZW5kZXIoKSB0byBraWNrIGl0IG9mZiBhZ2Fpbi5cbiAgICAgICAgSWYgeW91IGRvbid0IHdhbnQgdGhlIFdoZW5DYW5JVXNlIGRhdGEgdG8gbG9hZCBpbiB0aGUgYmFja2dyb3VuZCwgdHVybiBCRV9SRUFEWSB0byBmYWxzZS5cbiAgICAqL1xuICAgIHZhciBBVVRPX1JVTiA9IHRydWUsXG4gICAgICAgIEJFX1JFQURZID0gdHJ1ZTtcblxuICAgIC8qICBDb25maWd1cmUgdGhlIGJyb3dzZXJzIHlvdSB3YW50IHRvIHNob3cgaGVyZS5cbiAgICAgICAgVGhlIG9yZGVyIGRlZmluZXMgdGhlIG9yZGVyIHRoZXkgd2lsbCBhcHBlYXIgb24gdGhlIHBhZ2UuXG5cbiAgICAgICAgQnJvd3NlciBvcHRpb25zIGFyZTpcbiAgICAgICAgKiBhbmRyb2lkICAgLSBBbmRyb2lkXG4gICAgICAgICogYW5kX2ZmICAgIC0gQW5kcm9pZCBGaXJlZm94XG4gICAgICAgICogYW5kX2NociAgIC0gQW5kcm9pZCBDaHJvbWVcbiAgICAgICAgKiBiYiAgICAgICAgLSBCbGFja2JlcnJ5XG4gICAgICAgICogY2hyb21lICAgIC0gR29vZ2xlIENocm9tZVxuICAgICAgICAqIGZpcmVmb3ggICAtIE1vemlsbGEgRmlyZWZveFxuICAgICAgICAqIGllICAgICAgICAtIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAgICogaW9zX3NhZiAgIC0gaU9TIFNhZmFyaVxuICAgICAgICAqIG9wZXJhICAgICAtIE9wZXJhXG4gICAgICAgICogb3BfbWluaSAgIC0gT3BlcmEgTWluaVxuICAgICAgICAqIG9wX21vYiAgICAtIE9wZXJhIE1vYmlsZVxuICAgICAgICAqIHNhZmFyaSAgICAtIEFwcGxlIFNhZmFyaVxuICAgICovXG4gICAgdmFyIEJST1dTRVJTID0gWydjaHJvbWUnLCAnZmlyZWZveCcsICdpZScsICdvcGVyYScsICdzYWZhcmknXTtcblxuICAgIC8vICBDdXN0b21pc2UgSFRNTCBoZXJlXG4gICAgdmFyIFRNUExfVElUTEUgPSAnPGgyPnt0aXRsZX08L2gyPicsIC8vIGZlYXR1cmUgdGl0bGUge3RpdGxlfVxuICAgICAgICBUTVBMX1NUQVRVUyA9ICc8cCBjbGFzcz1cInN0YXR1c1wiPntzdGF0dXN9PC9wPicsIC8vIGZlYXR1cmUgc3RhdHVzIChXM0MgUmVjb21tZW5kYXRpb24pIHtzdGF0dXN9XG4gICAgICAgIFRNUExfREVTQ1JJUFRJT04gPSAnPHA+U3Vwb3J0YWRvIGEgcGFydGlyIGRlOjwvcD4nLCAvLyBkZXNjcmlwdGlvbiB0byB1c2VyXG4gICAgICAgIFRNUExfREVTS1RPUF9USVRMRSA9ICcnLCAvLyBkZXNrdG9wIGhlYWRlclxuICAgICAgICBUTVBMX01PQklMRV9USVRMRSA9ICcnLCAvLyBtb2JpbGUgaGVhZGVyXG4gICAgICAgIFRNUExfU1VQUE9SVF9XUkFQUEVSID0gJzx1bCBjbGFzcz1cImFnZW50c1wiPntpdGVtc308L3VsPicsIC8vIHN1cHBvcnQgd3JhcHBlciB7aXRlbXN9XG4gICAgICAgIFRNUExfU1VQUE9SVCA9ICc8bGkgdGl0bGU9XCJ7YnJvd3Nlcn0gLSB7c3VwcG9ydH1cIiBjbGFzcz1cImljb24te2Jyb3dzZXJjb2RlfSB7c3VwcG9ydGNvZGV9XCI+PHNwYW4gY2xhc3M9XCJ2ZXJzaW9uXCI+e3ZlcnNpb259e3ByZWZpeGVkfTwvc3Bhbj48L2xpPicsXG4gICAgICAgIFRNUExfUFJFRklYX05PVEUgPSAnPHA+KiByZXF1ZXIgcHJlZml4by48L3A+JyxcbiAgICAgICAgVE1QTF9MRUdFTkQgPSAnPHVsIGNsYXNzPVwibGVnZW5kXCI+PGxpPkxlZ2VuZGE6PC9saT48bGkgY2xhc3M9XCJ5XCI+U2ltPC9saT48bGkgY2xhc3M9XCJuXCI+TsOjbzwvbGk+PGxpIGNsYXNzPVwiYVwiPlBhcmNpYWw8L2xpPjxsaSBjbGFzcz1cInBcIj5Qb2x5ZmlsbDwvbGk+PC91bD4nLFxuICAgICAgICBUTVBMX0ZPT1RFUiA9ICc8cCBjbGFzcz1cInN0YXRzXCI+RGFkb3MgZGUgPGEgaHJlZj1cImh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD17ZmVhdHVyZX1cIiB0YXJnZXQ9XCJfYmxhbmtcIj5jYW5pdXNlLmNvbTwvYT48L3A+JyxcbiAgICAgICAgVE1QTF9MT0FESU5HID0gJzxoMj5DYXJyZWdhbmRvPC9oMj4nLFxuICAgICAgICBUTVBMX0VSUk9SID0gJzxoMj5FcnJvPC9oMj48cD5GZWF0dXJlIFwie2ZlYXR1cmV9XCIgbsOjbyBlbmNvbnRyYWRhITwvcD4nO1xuXG4gICAgLyogRU5EIENPTkZJR1VSQVRJT04gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LSAqL1xuXG4gICAgdmFyIGNhbklVc2VEYXRhLCAvLyBzdG9yZSBkYXRhIGZvciBtdWx0aXBsZSB1c2VzLlxuICAgICAgICBzdG9yZUVsZW1lbnRJZCwgLy8gdGVtcCBzdG9yYWdlIGZvciBlbGVtZW50SWQgaWYgd2UgbmVlZCB0byBKU09OUCByZXF1ZXN0XG4gICAgICAgIHBvcHVsYXRlT25Mb2FkOyAvLyB0ZW1wIHN0b3JhZ2UgZm9yIGlmIHdlIHNob3VsZCBwb3B1bGF0ZVxuXG5cblxuICAgIC8vIGdldCBmZWF0dXJlIGRhdGEgYmFzZWQgb24gZmVhdHVyZSBuYW1lXG4gICAgZnVuY3Rpb24gZ2V0RmVhdHVyZShmZWF0dXJlTmFtZSkge1xuICAgICAgICBmZWF0dXJlTmFtZSA9IGZlYXR1cmVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChjYW5JVXNlRGF0YS5xdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbklVc2VEYXRhLnF1ZXJ5LnJlc3VsdHMuanNvbi5kYXRhW2ZlYXR1cmVOYW1lXTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW5JVXNlRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FuSVVzZURhdGEuZGF0YVtmZWF0dXJlTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldCB0aGUgZnVsbCB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgc3VwcG9ydCBzdGF0dXNcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0U3RhdHVzKGtleSkge1xuICAgICAgICB2YXIgc3RhdHVzID0ge1xuICAgICAgICAgICAgXCJ5XCI6IFwiWWVzXCIsXG4gICAgICAgICAgICBcInhcIjogXCJXaXRoIFByZWZpeFwiLFxuICAgICAgICAgICAgXCJuXCI6IFwiTm9cIixcbiAgICAgICAgICAgIFwiYVwiOiBcIlBhcnRpYWwgU3VwcG9ydFwiLFxuICAgICAgICAgICAgXCJwXCI6IFwiUG9seWZpbGxcIixcbiAgICAgICAgICAgIFwidVwiOiBcIlVua25vd25cIlxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdGF0dXNba2V5XTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHNwZWNpZmljYXRpb24gc3RhdHVzXG4gICAgZnVuY3Rpb24gZ2V0U3BlY1N0YXR1cyhrZXkpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHtcbiAgICAgICAgICAgIFwicmVjXCI6IFwiVzNDIFJlY29tbWVuZGF0aW9uXCIsXG4gICAgICAgICAgICBcInByXCI6IFwiVzNDIFByb3Bvc2VkIFJlY29tbWVuZGF0aW9uXCIsXG4gICAgICAgICAgICBcImNyXCI6IFwiVzNDIENhbmRpZGF0ZSBSZWNvbW1lbmRhdGlvblwiLFxuICAgICAgICAgICAgXCJ3ZFwiOiBcIlczQyBXb3JraW5nIERyYWZ0XCIsXG4gICAgICAgICAgICBcIm90aGVyXCI6IFwiTm9uLVczQywgYnV0IFJlcHV0YWJsZVwiLFxuICAgICAgICAgICAgXCJ1bm9mZlwiOiBcIlVub2ZmaWNpYWwgb3IgVzNDICdOb3RlJ1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0YXR1c1trZXldIHx8IFwiVW5rbm93blwiO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IHZlcnNpb24gdGhhdCBoYWQgdGhpcyBzdGF0dXNcbiAgICBmdW5jdGlvbiBmaW5kKG5lZWRsZSwgaGF5c3RhY2spIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIFwidmVyc2lvblwiOiAtMSxcbiAgICAgICAgICAgICAgICBcInByZWZpeGVkXCI6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGFyZSA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGl0ZW0gaW4gaGF5c3RhY2spIHtcbiAgICAgICAgICAgIGlmIChoYXlzdGFjay5oYXNPd25Qcm9wZXJ0eShpdGVtKSAmJiBoYXlzdGFja1tpdGVtXS5pbmRleE9mKG5lZWRsZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyBhcmUgZm9ybWF0dGVkIG4tbiwgdGFrZSB0aGUgZmlyc3QgbnVtYmVyIGZvciBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IHBhcnNlRmxvYXQoaXRlbS5zcGxpdCgnLScpWzBdKTtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHZlcnNpb24gbG93ZXIgdGhhbiB0aGUgY3VycmVudCB2ZXJzaW9uIHdlIGhhdmUgc3RvcmVkP1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyc2lvbiA9PT0gLTEgfHwgcmVzdWx0LnZlcnNpb24gPiBjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gY29tcGFyZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnByZWZpeGVkID0gKGhheXN0YWNrW2l0ZW1dLmluZGV4T2YoJ3gnKSA+IC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kU3VwcG9ydChicm93c2VyRGF0YSkge1xuICAgICAgICB2YXIgc3RhdHVzID0gWyd5JywgJ2EnLCAncCddLFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIGZpbmQgd2hhdCBzdXBwb3J0IGlzIGF2YWlsYWJsZSBmb3IgdGhpcyBicm93c2VyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaW5kKHN0YXR1c1tpXSwgYnJvd3NlckRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ZXJzaW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICdyZXN1bHQnOiBzdGF0dXNbaV0sIC8vIHdoYXQgdHlwZSBvZiBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICdwcmVmaXhlZCc6IHJlc3VsdC5wcmVmaXhlZCxcbiAgICAgICAgICAgICAgICAgICAgJ3ZlcnNpb24nOiAocmVzdWx0LnZlcnNpb24gIT09ICcwJykgPyByZXN1bHQudmVyc2lvbiA6ICcwJyAvLyB0aGUgdmVyc2lvbiB3aXRoIHRoYXQgc3VwcG9ydFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdyZXN1bHQnOiAnbicsXG4gICAgICAgICAgICAncHJlZml4ZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ05vJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qIHB1dCB0aGUgZGF0YSBpbiBhIG1vcmUgcGxhdGFibGUgZm9ybWF0ICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSZXN1bHRzKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIGFnZW50cyA9IHt9LFxuICAgICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgICAgY3VycmVudEJyb3dzZXIgPSAnJyxcbiAgICAgICAgICAgIHN1cHBvcnQgPSB7fTtcblxuICAgICAgICBhZ2VudHMgPSBjYW5JVXNlRGF0YS5hZ2VudHMgfHwgY2FuSVVzZURhdGEucXVlcnkucmVzdWx0cy5qc29uLmFnZW50cztcblxuICAgICAgICByZXN1bHRzLnRpdGxlID0gZmVhdHVyZS50aXRsZTsgLy8gZmVhdHVyZSBuYW1lXG4gICAgICAgIHJlc3VsdHMuY29kZSA9IGZlYXR1cmU7IC8vIGZlYXR1cmUgY29kZT9cbiAgICAgICAgcmVzdWx0cy5zdGF0dXMgPSBnZXRTcGVjU3RhdHVzKGZlYXR1cmUuc3RhdHVzKTsgLy8gZmVhdHVyZSBzcGVjaWZpY2F0aW9uIHN0YXR1c1xuICAgICAgICByZXN1bHRzLmFnZW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gQlJPV1NFUlMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGN1cnJlbnRCcm93c2VyID0gQlJPV1NFUlNbaV07XG5cbiAgICAgICAgICAgIGlmIChhZ2VudHNbY3VycmVudEJyb3dzZXJdKSB7XG5cbiAgICAgICAgICAgICAgICBzdXBwb3J0ID0gZmluZFN1cHBvcnQoZmVhdHVyZS5zdGF0c1tCUk9XU0VSU1tpXV0pO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5hZ2VudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFwiYnJvd3NlcmNvZGVcIjogY3VycmVudEJyb3dzZXIsXG4gICAgICAgICAgICAgICAgICAgIFwicHJlZml4ZWRcIjogc3VwcG9ydC5wcmVmaXhlZCxcbiAgICAgICAgICAgICAgICAgICAgXCJzdXBwb3J0Y29kZVwiOiBzdXBwb3J0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgXCJzdXBwb3J0XCI6IGdldFN1cHBvcnRTdGF0dXMoc3VwcG9ydC5yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IGFnZW50c1tjdXJyZW50QnJvd3Nlcl0uYnJvd3NlcixcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IGFnZW50c1tjdXJyZW50QnJvd3Nlcl0udHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBcInZlcnNpb25cIjogc3VwcG9ydC52ZXJzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSHRtbChyZXN1bHRzKSB7XG5cbiAgICAgICAgdmFyIGh0bWwgPSAnJyxcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgPSAnJyxcbiAgICAgICAgICAgIGRlc2t0b3BIdG1sID0gJycsXG4gICAgICAgICAgICBtb2JpbGVIdG1sID0gJycsXG4gICAgICAgICAgICBwcmVmaXhlcyA9IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSAwO1xuXG4gICAgICAgIHJlc3VsdEh0bWwgPSBUTVBMX1RJVExFLnJlcGxhY2UoJ3t0aXRsZX0nLCByZXN1bHRzLnRpdGxlKTtcbiAgICAgICAgcmVzdWx0SHRtbCArPSBUTVBMX1NUQVRVUy5yZXBsYWNlKCd7c3RhdHVzfScsIHJlc3VsdHMuc3RhdHVzKTtcbiAgICAgICAgcmVzdWx0SHRtbCArPSBUTVBMX0RFU0NSSVBUSU9OO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSByZXN1bHRzLmFnZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMuYWdlbnRzW2ldOyAvLyBzaW1wbHkgdGhpbmdzXG5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2hvdyB0aGF0IHByZWZpeCBub3RpY2UsIGNhcHRhaW5cbiAgICAgICAgICAgIGlmIChyZXN1bHQucHJlZml4ZWQpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXhlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgPSBUTVBMX1NVUFBPUlQucmVwbGFjZSgvXFx7YnJvd3NlcmNvZGVcXH0vZywgcmVzdWx0LmJyb3dzZXJjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce3ByZWZpeGVkXFx9L2csIChyZXN1bHQucHJlZml4ZWQgPT09IHRydWUpID8gJyonIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7c3VwcG9ydGNvZGVcXH0vZywgcmVzdWx0LnN1cHBvcnRjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce3N1cHBvcnRcXH0vZywgcmVzdWx0LnN1cHBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7YnJvd3NlclxcfS9nLCByZXN1bHQudGl0bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7dmVyc2lvblxcfS9nLCByZXN1bHQudmVyc2lvbik7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Rlc2t0b3AnKSB7XG4gICAgICAgICAgICAgICAgZGVza3RvcEh0bWwgKz0gaHRtbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnR5cGUgPT09ICdtb2JpbGUnKSB7XG4gICAgICAgICAgICAgICAgbW9iaWxlSHRtbCArPSBodG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBzaG93IGlmIHdlIGFyZSBpbmNsdWRpbmcgZGVza3RvcCBicm93c2Vyc1xuICAgICAgICBpZiAoZGVza3RvcEh0bWwgIT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHRIdG1sICs9IFRNUExfREVTS1RPUF9USVRMRTtcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9TVVBQT1JUX1dSQVBQRVIucmVwbGFjZSgvXFx7aXRlbXNcXH0vZywgZGVza3RvcEh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBzaG93IGlmIHdlIGFyZSBpbmNsdWRpbmcgbW9iaWxlIGJyb3dzZXJzXG4gICAgICAgIGlmIChtb2JpbGVIdG1sICE9PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0SHRtbCArPSBUTVBMX01PQklMRV9USVRMRTtcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9TVVBQT1JUX1dSQVBQRVIucmVwbGFjZSgvXFx7aXRlbXNcXH0vZywgbW9iaWxlSHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZml4ZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9QUkVGSVhfTk9URTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9MRUdFTkQ7XG4gICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9GT09URVIucmVwbGFjZSgvXFx7ZmVhdHVyZVxcfS9nLCByZXN1bHRzLmZlYXR1cmVDb2RlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdEh0bWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUoZWxlbWVudElkKSB7XG4gICAgICAgIHZhciAkY2FuSVVzZSA9IFtdLFxuICAgICAgICAgICAgJGluc3RhbmNlLFxuICAgICAgICAgICAgZmVhdHVyZUNvZGUgPSAnJyxcbiAgICAgICAgICAgIGZlYXR1cmUgPSB7fSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsID0gMDtcblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRJZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgJGNhbklVc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FuaXVzZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGNhbklVc2UucHVzaChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGwgPSAkY2FuSVVzZS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgJGluc3RhbmNlID0gJGNhbklVc2VbaV07XG4gICAgICAgICAgICBmZWF0dXJlQ29kZSA9ICRpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmVhdHVyZScpIHx8ICd1bmtub3duJztcbiAgICAgICAgICAgIGZlYXR1cmUgPSBnZXRGZWF0dXJlKGZlYXR1cmVDb2RlKTtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHRzKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mZWF0dXJlQ29kZSA9IGZlYXR1cmVDb2RlO1xuICAgICAgICAgICAgICAgICRpbnN0YW5jZS5pbm5lckhUTUwgPSBnZW5lcmF0ZUh0bWwocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGluc3RhbmNlLmlubmVySFRNTCA9IFRNUExfRVJST1IucmVwbGFjZSgvXFx7ZmVhdHVyZVxcfS9nLCBmZWF0dXJlQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93TG9hZGluZyhlbGVtZW50SWQpIHtcbiAgICAgICAgdmFyICRjYW5JVXNlID0gW10sXG4gICAgICAgICAgICAkaW5zdGFuY2UsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudElkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAkY2FuSVVzZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYW5pdXNlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkY2FuSVVzZS5wdXNoKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbCA9ICRjYW5JVXNlLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAkaW5zdGFuY2UgPSAkY2FuSVVzZVtpXTtcbiAgICAgICAgICAgICRpbnN0YW5jZS5pbm5lckhUTUwgPSBUTVBMX0xPQURJTkc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIExvYWQgdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRGF0YShlbGVtZW50SWQsIHBvcHVsYXRlKSB7XG4gICAgICAgIHZhciB1cmwgPSAnJyxcbiAgICAgICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1NDUklQVCcpO1xuXG4gICAgICAgIHVybCA9ICdodHRwOi8vcXVlcnkueWFob29hcGlzLmNvbS92MS9wdWJsaWMveXFsP3E9JyArXG4gICAgICAgICAgICAnc2VsZWN0ICogZnJvbSBqc29uIHdoZXJlIHVybCA9IFxcJycgKyBTT1VSQ0VfREFUQV9VUkwgKyAnXFwnJyArXG4gICAgICAgICAgICAnJmZvcm1hdD1qc29uJmpzb25Db21wYXQ9bmV3JmNhbGxiYWNrPWNhbklVc2VEYXRhTG9hZGVkJztcblxuICAgICAgICAvLyByZW1lbWJlciB0aGVzZSBmb3Igd2hlbiBvdXIgSlNPTlAgcmV0dXJuc1xuICAgICAgICBzdG9yZUVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgcG9wdWxhdGVPbkxvYWQgPSBwb3B1bGF0ZTtcblxuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wdWxhdGUoZWxlbWVudElkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FuSVVzZURhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaG93TG9hZGluZyhlbGVtZW50SWQpO1xuICAgICAgICAgICAgbG9hZERhdGEoZWxlbWVudElkLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlbmVyYXRlKGVsZW1lbnRJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFB1YmxpYyBNZXRob2RzXG4gICAgICovXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiBwb3B1bGF0ZSxcbiAgICAgICAgZGF0YUxvYWRlZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGNhbklVc2VEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGlmIChwb3B1bGF0ZU9uTG9hZCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlKHN0b3JlRWxlbWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChBVVRPX1JVTikge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEJFX1JFQURZKSB7XG4gICAgICAgICAgICAgICAgbG9hZERhdGEodW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9O1xufSgpKTtcblxud2luZG93LmNhbklVc2VEYXRhTG9hZGVkID0gZnVuY3Rpb24gY2FuSVVzZURhdGFMb2FkZWQoZGF0YSkge1xuICAgIGNhbklVc2UuZGF0YUxvYWRlZChkYXRhKTtcbn07XG4iXX0=